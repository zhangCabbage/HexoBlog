---
title: 17年网易有道内推笔试---构造队列
date: 2017-01-14 21:55:27
categories: 算法
tags: [算法, 约瑟夫环]
---
无意中看到这道笔试题，想想自己已经估摸快一个多月没有刷算法题；简直羞愧难当，越来越水了，就试试当热热手...
## 题目
小明同学把1到n这n个数字按照一定的顺序放入了一个队列Q中。现在他对队列Q执行了如下程序：
```
while(!Q.empty()) //队列不空，执行循环
{
    int x=Q.front(); //取出当前队头的值x
    Q.pop(); //弹出当前队头
    Q.push(x); //把x放入队尾
    x = Q.front(); //取出这时候队头的值
    printf("%d\n",x); //输出x
    Q.pop(); //弹出这时候的队头
}
```
<!--more-->
做取出队头的值操作的时候，并不弹出当前队头。小明同学发现，这段程序恰好按顺序输出了1,2,3,…,n。现在小明想让你构造出原始的队列，你能做到吗？
**输入描述:**
第一行一个整数T（T ≤ 100）表示数据组数，每组数据输入一个数n（1 ≤ n ≤ 100000），输入的所有n之和不超过200000。
**输出描述:**
对于每组数据，输出一行，表示原始的队列。数字之间用一个空格隔开，不要在行末输出多余的空格.
**输入例子:**
```
4
1
2
3
10
```
**输出例子:**
```
1
2 1
2 1 3
8 1 6 2 10 3 7 4 9 5
```

## 分析
首先只考虑f(n)输出`1, 2, 3...n`，我第一念头是按照程序逻辑逆推，按照`n, n-1 ... 3, 2, 1`的顺序把全部元素回插入队列。先只分析`1, 2, 3`的情况：首先回插3，队列集合为`[3]`；之后回插2，根据输出逻辑，当回插时每次需要把最后一个元素移至队列头，此时队列集合为`[3, 2]`；最后回插1，同理得队列集合为`[2, 1, 3]`。ok逆推成功，这道题不是还是挺容易的。
Java程序如下所示：
```Java
public void generateQueue1(int n) {
    List<Integer> list = new LinkedList<>();
    for (int i = n; i > 0; i--) {
        list.add(0, i);
        list.add(0, list.get(list.size() - 1));
        list.remove(list.size() - 1);
    }
    System.out.println(list.toString());
}
```
当然如果这道题分析仅仅是这样的话，那这篇博文也没有啥写的必要了。各位看官，你看到这里时，有啥别的想法思路不？后面紧接着将记录几个新颖的解题思路，虽然最后证明上面简单的逆推算法效率上基本是最高的，但是新奇的思路总是显得比较好玩。

## 头脑风暴
### 开胃菜
这盘开胃菜的主要思路如下：
> 以`1, 2 ... n-1, n`为原始队列元素，按照题目队列输出逻辑操作得到输出结果，之后以输出结果的值为下标把对应数组处填入值对应的下标。

上面这句话可能比较拗口难以理解，我们举个栗子来说明一下：假如n=3，此时队列为[1, 2, 3]，通过输出逻辑输出结果数组`2, 1, 3`，其对应的下标为`1, 2, 3`。那么我们填入结果数组res方式为：`res[2] = 1, res[1] = 2, res[3] = 3`。（注意：上述栗子中为了方便说明，下标没有从0开始）
Java程序如下：
```Java
public void generateQueue2(int n) {
    List<Integer> original = new LinkedList<>();
    for (int i = 1; i <= n; i++) {
        original.add(i);
    }
    int[] tmp = new int[n];
    int i = 0;
    while (original.size() != 0) {
        original.add(original.get(0));
        original.remove(0);
        tmp[i++] = original.get(0);
        original.remove(0);
    }

    int[] res = new int[n];
    for (int j = 0; j < n; j++) {
        res[tmp[j] - 1] = j + 1;
    }
    for (int j = 0; j < n; j++) {
        System.out.print(res[j] + " ");
    }
    System.out.println();
}
```
通过上面的程序我们可以看到，虽然时间复杂度也为O(n)，但是其系数比逆推方法大。(能听我啰嗦看到这里了，简直是真爱！最重要的来了，那就继续往下看吧...)

### 主菜
下面主菜来了，我看到讨论区有不少人说可以用[约瑟夫环][1]。不懂`约瑟夫环`的胖友们得纠结了，啥叫`约瑟夫环`呀，听着好高端的样子。后面我会单独开一篇约瑟夫环问题的剖析，其精髓就是：**约瑟夫环的前后状态间可以相互迭代推导，下标之间可以很容易实现转换**。建议大家在了解约瑟夫环的前提下，进一步思考这道题如何使用约瑟夫环来进行分析，后面我将假设大家对约瑟夫环有一定的了解。(ヾ(｡｀Д´｡)刚说让我继续往下看，现在又来这一手，玩我呢[掀桌子...)

别打我，其实也并不需要太深入了解，后面都会用直白的栗子说明，看得懂的啦。这里是希望大家看完这道题，去了解约瑟夫环之后，能再回过来想一下下面我的解题方式，或许可以帮助大家更深入理解约瑟夫环问题。

约瑟夫环解题思路：通过迭代来帮助我们把[0,1]范围内的问题解，映射到[0,2]，之后继续向上映射最终得到[0,n-1]范围内的解。根据题意(我擦，这句话好像做数学应用题的套路)：对于队列`0, 1, 2, 3 ... n-2, n-1`，获取第一个元素后队列为`2, 3, 4, 5 ... n-2, n-1, 0`，我们可以把这个队列通过`(x - 2 + n) % n`转化为`0, 1, 2, 3 ... n-3, n-2`。反过来，也可以把`0, 1, 2, 3 ... n-3, n-2`通过`(x + 2) % n`向上映射成`0, 1, 2, 3 ... n-2, n-1`。故[0,n-2]内遍历的第一个元素，通过`(x + 2) % i`可以转化为[0, n-1]内遍历的第二个元素。

通过上面的思路分析，我们可以知道，`约瑟夫环问题`可以把下层(规模小的问题)中也是上层(规模大的问题)的解层层映射，最终迭代转换成想要求得问题规模的解。这里要注意：**要求的问题规模下的解需要也在下层(规模小的问题)中才能进行转化**。

那么有了上面的分析，这道题该继续怎么进行解答呢？考虑到我们可以很容易的求得任何问题规模下的第一个遍历元素下标，有如下思路：
>`[0, n-2]`第1次遍历 --> 是`[0, n-1]`中第2次遍历的下标, 迭代1次
`[0, n-3]`第1次遍历 --> 是`[0, n-1]`中第3次遍历的下标, 迭代2次
.
.
.
`[0, 1]`第1次遍历 --> 是`[0, n-1]`中第n-1次遍历的下标, 迭代n-2次
`[0, 0]`第1次遍历 --> 是`[0, n-1]`中第n遍历的下标, 迭代n-1次

Java程序如下：
```java
public static void generateQueue3(int n) {
    int[] res = new int[n]; //结果数组
    int x = 1; //表示第几个遍历的元素

    if (n > 1) res[1] = x++; //第1个下标是1

    int index;
    for (int i = 0; i < n - 2; i++) { //后续第2~n-1个元素下标
        index = 1;
        for (int j = n - i; j <= n; j++) {
            index = (index + 2) % j;
        }
        res[index] = x++;
    }

    index = 0; //最后第n个元素下标
    for (int i = 2; i <= n; i++) {
        index = (index + 2) % i;
    }
    res[index] = x;

    for (int i = 0; i < n; i++) {
        System.out.print(res[i] + " ");
    }
    System.out.println();
}
```
很明显我们可以知道我上述约瑟夫环的方式，时间复杂度为O(n^2)

> 以上方法要么是原创，要么是根据别人思路自己想的，受限于自身知识可能解决问题的方法不是很好，如果大家有更好的这个思路下的解法欢迎留言。

[1]:https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98









